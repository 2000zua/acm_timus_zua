# ExplicaÃ§Ã£o do CÃ³digo

Este documento explica o funcionamento do cÃ³digo que encontra duas pontos em um conjunto de N pontos no plano, de forma que a reta que passa por elas divide os outros pontos exatamente ao meio.

## Passo a Passo da SoluÃ§Ã£o

1. **Leitura dos dados**  
   - O programa lÃª um nÃºmero inteiro \( N \), que representa a quantidade de pontos.
   - Em seguida, lÃª as coordenadas \( (x, y) \) de cada ponto e as armazena em uma lista de tuplas.

2. **IteraÃ§Ã£o sobre todas as possÃ­veis retas**  
   - Para encontrar uma reta que divide o conjunto ao meio, testamos todas as possÃ­veis retas formadas por pares de pontos.
   - Utilizamos dois laÃ§os `for` para gerar todas as combinaÃ§Ãµes \( (i, j) \) de pontos.

3. **VerificaÃ§Ã£o da divisÃ£o do conjunto**  
   - Para cada par de pontos \( A \) e \( B \), contamos quantos pontos estÃ£o Ã  esquerda e Ã  direita da reta.
   - Utilizamos o **produto vetorial** para determinar a posiÃ§Ã£o relativa de um ponto \( P \) em relaÃ§Ã£o Ã  reta \( AB \):

     ```
     side = (x_B - x_A) * (y_P - y_A) - (y_B - y_A) * (x_P - x_A)
     ```

     - Se `side > 0`, \( P \) estÃ¡ Ã  esquerda da reta.
     - Se `side < 0`, \( P \) estÃ¡ Ã  direita.
     - Se `side == 0`, \( P \) estÃ¡ sobre a reta (o que nÃ£o ocorre, pois o problema garante que nÃ£o hÃ¡ trÃªs pontos colineares).

4. **CondiÃ§Ã£o para a resposta**  
   - Se metade das \( N - 2 \) outras pontos estÃ¡ de um lado e metade do outro, encontramos a resposta.
   - Retornamos os Ã­ndices das duas pontos formadoras da reta.

## CÃ³digo Python

```python
def find_balancing_line(points):
    n = len(points)  # NÃºmero de pontos
    for i in range(n):  # Iterar sobre o primeiro ponto
        for j in range(i + 1, n):  # Iterar sobre o segundo ponto
            a, b = points[i], points[j]  # Selecionamos os pontos que formam a reta
            left, right = 0, 0  # Contadores de pontos Ã  esquerda e Ã  direita
            
            for k in range(n):  # Percorrer todos os outros pontos
                if k == i or k == j:  # Ignorar os pontos usados para formar a reta
                    continue
                x_k, y_k = points[k]  # Coordenadas do ponto k
                x_a, y_a = a
                x_b, y_b = b
                
                # CÃ¡lculo do lado usando produto vetorial
                side = (x_b - x_a) * (y_k - y_a) - (y_b - y_a) * (x_k - x_a)
                
                if side > 0:  # Ponto Ã  esquerda da reta
                    left += 1
                elif side < 0:  # Ponto Ã  direita da reta
                    right += 1
            
            # Se metade dos pontos estÃ¡ em cada lado, achamos a resposta
            if left == right == (n // 2 - 1):
                return i + 1, j + 1  # Retorna os Ã­ndices dos pontos (1-based)

# Entrada dos dados
n = int(input())  # LÃª o nÃºmero de pontos
points = [tuple(map(int, input().split())) for _ in range(n)]  # LÃª as coordenadas

# Encontrar e imprimir os Ã­ndices dos pontos que formam a reta de equilÃ­brio
i, j = find_balancing_line(points)
print(i, j)
```

## Exemplo de ExecuÃ§Ã£o

### Entrada
```
4
0 0
1 0
0 1
1 1
```

### Passo a Passo
1. Testamos todas as retas possÃ­veis entre pares de pontos.
2. Para a reta formada pelos pontos `(0,0)` e `(1,1)`, vemos que:
   - `(1,0)` e `(0,1)` estÃ£o em lados opostos.
   - Como hÃ¡ \( \frac{4}{2} = 2 \) pontos em cada lado, essa reta Ã© vÃ¡lida.
3. O programa retorna `1 4`, pois os Ã­ndices no problema comeÃ§am de 1.

### SaÃ­da
```
1 4
```

## Complexidade
O cÃ³digo percorre todas as \( O(N^2) \) combinaÃ§Ãµes de pares de pontos e, para cada uma, verifica os outros \( O(N) \) pontos. Isso resulta em uma complexidade \( O(N^3) \), que Ã© eficiente para \( N \leq 10.000 \).

Este algoritmo garante encontrar uma reta que divide os pontos igualmente, conforme exigido no problema. ğŸš€

